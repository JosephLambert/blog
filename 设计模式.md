# 设计模式



## 面向对象

对象：一个自包含的实体，用一组可识别的特性和行为来标识。

类：具有相同属性和功能的对象的抽象的集合。

构造方法：类初始化实例时调用的方法。

属性：一对方法，实质是用来读取（get set）的实例变量，看起来像字段，存在于内存中。

访问控制：

- public 外界可调用，子类可继承，内部可调用。
- protected 外界不可调用，子类可继承，内部可调用。
- private 外界不可调用，子类不可继承，内部可调用。

**面向对象三大特性**：

**封装**：每个对象都包含它能进行操作所需要的所有信息。

好处

1. 减少耦合
2. 类内部实现可以自由修改
3. 类具有清晰的对外接口

**继承**：继承代表了一种'is-a'的关系或者是子类对父类的特殊化(继承父类特性+定义自己特性+方法重写)

好处

代码共享，避免重复

坏处

继承是类和类之前强耦合的关系，父类变，子类不得不变。另外会破坏封装。

所以要注意使用条件，'is-a'

**多态**：不同的对象执行相同的动作，鸭子型别。



## 设计模式六大原则

1. **开闭原则（Open Close Principle）**

对扩展开放，对修改关闭，带来面向对象的好处：可维护、可拓展、可复用、灵活性好。

核心：预测变化，创建抽象隔离同类变化。也就是通过增加新代码，而不是修改已有代码。

2. **里氏代换原则（Liskov Substitution Principle）**

任何基类可以出现的地方，子类一定可以出现。

3. **依赖倒转原则（Dependence Inversion Principle）**

针对接口编程，细节应该依赖于抽象。

4. **单一职责原则（Single Responsibility Principle）**

对一个类而言，应该仅有一个引起它变化的原因。

5. **迪米特法则，又称最少知道原则（Demeter Principle）**

一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6. **合成复用原则（Composite Reuse Principle）**

尽量优先使用合成/聚合（has-a）的方式，而不是使用继承（is-a）。



## 设计模式四大分类

### 创建型模式

**创建型模式**：这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。



#### 单例模式

一个类只能实例化一个对象，并提供控制访问该对象的方法。

#### 工厂方法模式

提供一个接口，创建一个对象，而无需指定具体的类。由于抽象了创建过程，所以创建可以有很大灵活性。

#### 抽象工厂模式 

提供一个接口，创建一系列或若干相关依赖对象，而无需指定具体的类。

#### 建造者模式 

主要用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，带对象内部构建面临复杂变化。

#### 原型模式

在初始化信息不发生变化的情况下，用克隆(浅复制+深复制)。既隐藏对象创建的细节，有提高性能。

建立相应数目的原型并克隆更方便。



### 结构型模式

**结构型模式** 这些设计模式关注类和对象的组合、关系。



#### 适配器模式

将原本接口不兼容而不能一起工作的那些类可以一起工作。

#### 桥接模式

当系统有多角度分类，每一种分类都会有可能变化，那么把多角度分离出来让他们独立变化，减少耦合。

优先使用关联而非继承。

#### 组合模式

将对象组合成树形结构以表示'部分-整体'的结构层次，并提供一个调用对象的统一接口。

#### 装饰模式

动态给一个对象增加一些额外的职责。当新功能仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要，简化原有类。

#### 外观模式

定义了一个高层接口，该接口封装了对若干相互并列的子系统的调用。

#### 享元模式

当使用大量对象造成很大开销，而且这些对象的大多数是相同的内部状态，而少数是不同的外部状态。

#### 代理模式

为对象提供代理以控制访问。



### 行为型模式

**行为型模式** 这些设计模式特别关注对象之间的通信。



#### 观察者模式

又叫发布订阅模式，当一个对象的状态改变，所有依赖于它的对象都会得到通知并自动更新。

#### 模板方法模式

父类定义算法的骨架，子类定义该算法的特定步骤。

#### 命令模式

抽象请求，可以记录日志、排队、撤销。

#### 状态模式

当条件表达式过于复杂，既可以把判断逻辑抽象为一系列类。类似状态机。

#### 职责链模式

有多个对象可以处理请求，哪个对象处理该请求事先并不知道，要在运行时自动确认。将请求的处理者连成一条链，并沿着该链条传递该请求，直到有一个对象处理它为止。

#### 解释器模式

自定义一种语言、文法，并定义解释器，解释语言中的句子。

#### 中介者模式

用中介对象封装对象的交互，使得各对象不需要显示的引用，只需知道中介即可，减少相互连接的数目。

#### 访问者模式

用于数据结构稳定的系统，将数据结构和操作解耦，使得操作可以灵活变化。

#### 策略模式

封装一系列算法，完成相同的工作，实现不同，可以相互替换并容易变化的算法。

#### 备忘录模式

捕获对象内部状态，并保存在外部对象中，需要时可以恢复。

#### 迭代器模式

提供访问集合中各个元素，而不暴露对象的内部表示的接口，如开始、下一个、是否结束、当前项目。



## 设计模式关系图谱

![设计模式关系](https://7n.w3cschool.cn/attachments/uploads/2014/08/the-relationship-between-design-patterns.jpg)


